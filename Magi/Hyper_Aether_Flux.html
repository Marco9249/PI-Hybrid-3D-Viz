<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HYPER-AETHER FLUX | ULTIMATE DAZZLE</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/ScrollTrigger.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Outfit:wght@100;400;900&family=Cinzel:wght@900&display=swap');

        :root {
            --primary: #00f2ff;
            --secondary: #bc00ff;
            --bg: #050508;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            cursor: none !important;
        }

        body {
            background: var(--bg);
            color: #fff;
            font-family: 'Outfit', sans-serif;
            overflow-x: hidden;
        }

        #container {
            position: fixed;
            inset: 0;
            z-index: -1;
        }

        /* Cinematic UI */
        .vignette {
            position: fixed;
            inset: 0;
            background: radial-gradient(circle, transparent 20%, rgba(0, 0, 0, 0.8));
            pointer-events: none;
            z-index: 1000;
        }

        .noise {
            position: fixed;
            inset: 0;
            background: url('https://upload.wikimedia.org/wikipedia/commons/7/76/1k_p_Nois_6.png');
            opacity: 0.04;
            pointer-events: none;
            z-index: 1001;
            mix-blend-mode: overlay;
        }

        #cursor {
            width: 40px;
            height: 40px;
            border: 1px solid var(--primary);
            border-radius: 50%;
            position: fixed;
            pointer-events: none;
            z-index: 10000;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #cursor-pulse {
            width: 6px;
            height: 6px;
            background: var(--primary);
            border-radius: 50%;
            box-shadow: 0 0 15px var(--primary);
            animation: pulse 2s infinite;
        }

        .hero {
            height: 100vh;
            display: flex;
            align-items: center;
            padding: 0 10%;
        }

        .hero h1 {
            font-family: 'Outfit';
            font-size: 15vw;
            line-height: 0.8;
            font-weight: 900;
            letter-spacing: -10px;
            perspective: 1000px;
        }

        .hero h1 span {
            display: block;
            opacity: 0;
            transform: translateY(100px) rotateX(-90deg);
            filter: blur(20px);
        }

        .section {
            min-height: 100vh;
            display: flex;
            align-items: center;
            padding: 150px 10%;
        }

        .glass-panel {
            background: rgba(5, 5, 10, 0.9);
            backdrop-filter: blur(60px) saturate(160%);
            -webkit-backdrop-filter: blur(60px) saturate(160%);
            border: 1px solid rgba(255, 255, 255, 0.05);
            border-radius: 60px;
            padding: 90px;
            max-width: 800px;
            box-shadow: 0 60px 150px rgba(0, 0, 0, 0.8);
            opacity: 0;
            transform: translateY(100px);
        }

        .glass-panel h2 {
            font-size: 5rem;
            color: #fff;
            margin-bottom: 35px;
            line-height: 0.9;
            font-weight: 900;
            letter-spacing: -3px;
            text-shadow: 0 0 20px rgba(0, 242, 255, 0.3);
        }

        .glass-panel p {
            font-size: 1.4rem;
            line-height: 1.8;
            opacity: 0.7;
            font-weight: 300;
        }

        @keyframes pulse {

            0%,
            100% {
                transform: scale(1);
                opacity: 1;
            }

            50% {
                transform: scale(1.5);
                opacity: 0.5;
            }
        }

        /* Navigation */
        #nav-indicator {
            position: fixed;
            left: 40px;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            gap: 30px;
            z-index: 1100;
        }

        .nav-link {
            width: 2px;
            height: 30px;
            background: rgba(255, 255, 255, 0.1);
            transition: 0.4s;
        }

        .nav-link.active {
            background: var(--primary);
            height: 60px;
            box-shadow: 0 0 20px var(--primary);
        }
    </style>
</head>

<body>
    <div class="vignette"></div>
    <div class="noise"></div>
    <div id="cursor">
        <div id="cursor-pulse"></div>
    </div>

    <div id="nav-indicator">
        <div class="nav-link active"></div>
        <div class="nav-link"></div>
        <div class="nav-link"></div>
        <div class="nav-link"></div>
    </div>

    <div id="container"></div>

    <header class="hero">
        <h1 id="hero-title">
            <span>AETHER</span>
            <span>HYPER</span>
            <span>FLUX</span>
        </h1>
    </header>

    <section class="section">
        <div class="glass-panel reveal">
            <h2>Bio-Digital<br>Flow</h2>
            <p>Our research into the <strong>PI-Hybrid Architecture</strong> proved that solar forecasting in arid
                environments requires more than just heavy transformers. It requires the fluid logic of physics-embedded
                memory.</p>
            <div style="margin-top:50px; display:flex; gap:40px;">
                <div style="font-size:3rem; font-weight:900; color:var(--primary);">99.7%<span
                        style="font-size:10px; display:block; opacity:0.5; letter-spacing:5px;">STABILITY</span></div>
                <div style="font-size:3rem; font-weight:900; color:var(--secondary);">1.42s<span
                        style="font-size:10px; display:block; opacity:0.5; letter-spacing:5px;">RESPONSE</span></div>
            </div>
        </div>
    </section>

    <section class="section" style="justify-content: flex-end;">
        <div class="glass-panel reveal">
            <h2>Entropy Shift</h2>
            <p>As dust transients increase, the <strong>Kinetic Core</strong> of our model adjusts its temporal
                cathedral (BiLSTM) dynamically. Witness the precision of 492,000 algorithmic neurons in perfect sync.
            </p>
        </div>
    </section>

    <!-- Ribbon Shaders -->
    <script id="vShader" type="x-shader/x-vertex">
        uniform float uTime;
        uniform float uScroll;
        varying vec2 vUv;
        varying float vNoise;

        // Simplex Noise
        vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
        vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
        vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
        vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
        float snoise(vec3 v) {
            const vec2 C = vec2(1.0/6.0, 1.0/3.0);
            const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
            vec3 i = floor(v + dot(v, C.yyy));
            vec3 x0 = v - i + dot(i, C.xxx);
            vec3 g = step(x0.yzx, x0.xyz);
            vec3 l = 1.0 - g;
            vec3 i1 = min( g.xyz, l.zxy );
            vec3 i2 = max( g.xyz, l.zxy );
            vec3 x1 = x0 - i1 + C.xxx;
            vec3 x2 = x0 - i2 + C.yyy;
            vec3 x3 = x0 - D.yyy;
            i = mod289(i);
            vec4 p = permute( permute( permute( i.z + vec4(0.0, i1.z, i2.z, 1.0 )) + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));
            float n_ = 0.142857142857;
            vec3 ns = n_ * D.wyz - D.xzx;
            vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
            vec4 x_ = floor(j * ns.z);
            vec4 y_ = floor(j - 7.0 * x_ );
            vec4 x = x_ *ns.x + ns.yyyy;
            vec4 y = y_ *ns.x + ns.yyyy;
            vec4 h = 1.0 - abs(x) - abs(y);
            vec4 b0 = vec4( x.xy, y.xy );
            vec4 b1 = vec4( x.zw, y.zw );
            vec4 s0 = floor(b0)*2.0 + 1.0;
            vec4 s1 = floor(b1)*2.0 + 1.0;
            vec4 sh = -step(h, vec4(0.0));
            vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
            vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;
            vec3 p0 = vec3(a0.xy,h.x);
            vec3 p1 = vec3(a0.zw,h.y);
            vec3 p2 = vec3(a1.xy,h.z);
            vec3 p3 = vec3(a1.zw,h.w);
            vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
            p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w;
            vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
            m = m * m;
            return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) );
        }

        void main() {
            vUv = uv;
            vec3 pos = position;
            
            // Instanced flow logic
            // instanceMatrix is automatic in THREE.InstancedMesh
            // We use position in noise to create a global field
            float n = snoise(vec3(pos.x * 0.1, pos.y * 0.1, uTime * 0.2));
            vNoise = n;
            
            vec4 mvPosition = instanceMatrix * vec4(pos, 1.0);
            
            // Apply fluid displacement based on noise & scroll
            mvPosition.x += n * 2.0;
            mvPosition.y += sin(uTime + mvPosition.x * 0.1) * 2.0;
            mvPosition.z += cos(uTime * 0.5 + uScroll * 10.0) * 5.0;

            gl_Position = projectionMatrix * modelViewMatrix * mvPosition;
        }
    </script>
    <script id="fShader" type="x-shader/x-fragment">
        varying vec2 vUv;
        varying float vNoise;
        uniform float uTime;

        void main() {
            vec3 color1 = vec3(0.0, 0.95, 1.0); // Cyan
            vec3 color2 = vec3(0.74, 0.0, 1.0); // Purple
            
            vec3 finalColor = mix(color1, color2, vNoise * 0.5 + 0.5);
            float alpha = smoothstep(0.0, 0.1, vUv.x) * smoothstep(1.0, 0.9, vUv.x);
            alpha *= (vNoise * 0.5 + 0.5) * 0.8;

            gl_FragColor = vec4(finalColor, alpha);
        }
    </script>

    <script>
        const container = document.getElementById('container');
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x020205, 0.04);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 5, 20);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ReinhardToneMapping;
        renderer.toneMappingExposure = 2.2;
        container.appendChild(renderer.domElement);

        // --- INSTANCED RIBBON ENGINE ---
        const ribbonCount = 200;
        const ribbonGeo = new THREE.PlaneGeometry(10, 0.1, 50, 1);
        const ribbonMat = new THREE.ShaderMaterial({
            vertexShader: document.getElementById('vShader').textContent,
            fragmentShader: document.getElementById('fShader').textContent,
            transparent: true,
            side: THREE.DoubleSide,
            blending: THREE.AdditiveBlending,
            uniforms: {
                uTime: { value: 0 },
                uScroll: { value: 0 }
            }
        });

        const iMesh = new THREE.InstancedMesh(ribbonGeo, ribbonMat, ribbonCount);
        const matrix = new THREE.Matrix4();

        for (let i = 0; i < ribbonCount; i++) {
            matrix.setPosition(
                (Math.random() - 0.5) * 60,
                (Math.random() - 0.5) * 50,
                (Math.random() - 0.5) * 40
            );
            matrix.makeRotationZ(Math.random() * Math.PI);
            iMesh.setMatrixAt(i, matrix);
        }
        scene.add(iMesh);

        // 2. ATMOSPHERIC GALAXY
        const galaxyCount = 2000;
        const galaxyPos = new Float32Array(galaxyCount * 3);
        const galaxyColors = new Float32Array(galaxyCount * 3);
        for (let i = 0; i < galaxyCount; i++) {
            galaxyPos[i * 3] = (Math.random() - 0.5) * 80;
            galaxyPos[i * 3 + 1] = (Math.random() - 0.5) * 80;
            galaxyPos[i * 3 + 2] = (Math.random() - 0.5) * 80;
            const c = new THREE.Color(i % 2 === 0 ? 0x00f2ff : 0xbc00ff);
            galaxyColors[i * 3] = c.r;
            galaxyColors[i * 3 + 1] = c.g;
            galaxyColors[i * 3 + 2] = c.b;
        }
        const galaxyGeo = new THREE.BufferGeometry();
        galaxyGeo.setAttribute('position', new THREE.BufferAttribute(galaxyPos, 3));
        galaxyGeo.setAttribute('color', new THREE.BufferAttribute(galaxyColors, 3));
        const galaxyMat = new THREE.PointsMaterial({ size: 0.04, vertexColors: true, transparent: true, opacity: 0.2, blending: THREE.AdditiveBlending });
        const galaxy = new THREE.Points(galaxyGeo, galaxyMat);
        scene.add(galaxy);

        // 3. LIGHTING
        const pointLight1 = new THREE.PointLight(0x00f2ff, 12, 100);
        pointLight1.position.set(15, 15, 10);
        scene.add(pointLight1);

        const pointLight2 = new THREE.PointLight(0xbc00ff, 12, 100);
        pointLight2.position.set(-15, -15, 10);
        scene.add(pointLight2);

        // --- INTERACTION & GSAP APEX ---
        gsap.registerPlugin(ScrollTrigger);

        // Hero Typography Reveal
        gsap.to("#hero-title span", {
            opacity: 1, y: 0, rotateX: 0, filter: "blur(0px)",
            stagger: 0.2, duration: 2, ease: "expo.out", delay: 0.5
        });

        // Content Reveal
        gsap.utils.toArray(".reveal").forEach(el => {
            gsap.to(el, {
                scrollTrigger: { trigger: el, start: "top 80%", toggleActions: "play none none reverse" },
                opacity: 1, y: 0, duration: 1.5, ease: "expo.out"
            });
        });

        // Cinematic Camera Spline
        const curve = new THREE.CatmullRomCurve3([
            new THREE.Vector3(0, 5, 25),
            new THREE.Vector3(15, -5, 15),
            new THREE.Vector3(-15, 10, 10),
            new THREE.Vector3(0, 0, 15)
        ]);

        const scrollProxy = { val: 0 };
        gsap.to(scrollProxy, {
            val: 1,
            scrollTrigger: { trigger: "body", start: "top top", end: "bottom bottom", scrub: 3 },
            onUpdate: () => {
                const p = curve.getPoint(scrollProxy.val);
                camera.position.copy(p);
                camera.lookAt(0, 0, 0);
                ribbonMat.uniforms.uScroll.value = scrollProxy.val;
            }
        });

        // Loop
        function animate() {
            requestAnimationFrame(animate);
            ribbonMat.uniforms.uTime.value = performance.now() / 1000;
            iMesh.rotation.y += 0.001;
            renderer.render(scene, camera);
        }
        animate();

        // Cursor Flux
        const cursor = document.getElementById('cursor');
        document.addEventListener('mousemove', e => {
            gsap.to(cursor, {
                duration: 0.4,
                left: e.clientX - 20,
                top: e.clientY - 20,
                ease: "power3.out"
            });
            const x = (e.clientX / window.innerWidth - 0.5) * 2;
            const y = (e.clientY / window.innerHeight - 0.5) * 2;
            gsap.to(camera.position, { x: x * 5, y: -y * 5, duration: 2 });
        });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Navigation Sync
        window.addEventListener('scroll', () => {
            const sections = document.querySelectorAll('.hero, .section');
            const navDots = document.querySelectorAll('.nav-link');
            let current = 0;
            sections.forEach((s, i) => {
                if (window.pageYOffset >= s.offsetTop - 100) current = i;
            });
            navDots.forEach((dot, i) => {
                dot.classList.toggle('active', i === current);
            });
        });
    </script>
</body>

</html>